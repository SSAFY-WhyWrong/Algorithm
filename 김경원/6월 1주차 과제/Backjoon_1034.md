---
## Backjoon_1034 램프
### **Idea**
* 같은 곳을 2의 배수로 누르는 경우는 변화가 없다
* 어느 행을 전부 1로 만들기 위해 눌러야 하는 스위치의 수(cnt)가 K보다 많다면 전부 1로 만들 수가 없다.
* 필수 횟수만큼 누르고 남은 횟수가 홀수이면 절대로 그 행을 모두 1로 만들 수가 없다. (즉, (K-cnt)%2 == 0 이어야만 전부 1로 만드는 것이 가능하다 )
* 위의 조건을 만족하는 어느 행을 기준으로 똑같은 행이 몇개인지 확인한다.
* 전의 행에서 비교했을 때 똑같았던 행은 굳이 탐색하지 않아도 결과가 같다.
* 이렇게 확인하여 탐색된 최댓값을 구해준다


### ** 핵심 부분 구현**
```java
		for(int i=0;i<N;i++) {
			if(visit[i]) continue;
			visit[i] = true;
			cnt=0;
			
			//1로 바꿔야하는 열의 수 카운트
			for(int j=0;j<M;j++)
				if(arr[i][j]==0) cnt++;
			
			
			if(cnt <= K && (K-cnt)%2==0) { //바꿔야하는 0의 수가 K 이하면서 K만큼 눌른 후에 짝수 번 남는 경우만 확인 
				int temp=0;
				for(int t=i;t<N;t++) {// 위에서 같은 경우 봤으니깐 중복되는 경우는 안 봐도 됨
					if(isSame(arr[i],arr[t],M)) {
						visit[t] = true;
						temp++;
					}
				}
				result = Math.max(result,temp);
			}
			
			
		}


```

### 정리
단순하게 전부 뒤집어보면서 모든 경우의 수를 확인하는 방법을 선택하면
 
K번 또는 M + (K-M) mod 2 번 수행하여야 한다.

그렇다면 최악의 경우에  50^50 으로 시간초과를 할 수 밖에 없다.

그렇기에 일반적인 방법 대신 다른 방법으로 접근을 하여야 한다.

시간복잡도를 확인하고 아이디어를 고안하는 것이 중요한 문제였다.

